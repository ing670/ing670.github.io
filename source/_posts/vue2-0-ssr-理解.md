---
title: 'vue2.0 ssr 理解 '
date: 2017-08-25 16:02:24
tags:
- vue
- vue ssr
- js
---
### 服务端渲染
早些年，前端还没有工程化的时候，大部分web页面都是服务端渲染的，然后配合js完成交互。
举个例子，以前我们写的jsp页面，它其实会被编译成一个Servlet，Servlet是利用输出流动态生成HTML页面，包括每一个HTML标签和每个在HTML页面中出现的内容。
jsp并不是浏览器可以直接识别的html内容。而jsp到浏览器能识别的html的过程就是服务端渲染。
### 为什么现代框架重谈ssr(服务端渲染)
早些年的同一个网站访问不同的链接，会导致整个页面的重新刷新，特别是随着移动端的普及，在移动端这种加载页面方式，用户体验非常不好。
慢慢出现了SPA(Single Page Application)应用。SPA的优势就是一次性把所有的资源都下载下来。通过js来完成所有的交互。意味着，用户只是等待一次资源加载。
之后的所有操作，除了接口请求，不再有页面刷新。但是它有几个缺点：
1. seo问题--部分搜索引擎并不能收录js渲染出来的内容
2. 首页加载的问题--随着项目的复杂度越来越大，js越来越大。首屏加载时间越来越长
3. 如果浏览器禁用了js直接白屏问题
为了解决以上的问题，现代框架重新推出服务端渲染，如react ssr; vue ssr; angular ssr;

### 如何理解vue ssr
1. [官方文档](https://ssr.vuejs.org/)
2. [官方demo](https://github.com/vuejs/vue-hackernews-2.0/)
其实最快的方式就是弄懂官方的代码，我们先看一下官方工程的结构;
![示例图](/images/vuessr.png)
我们从`npm run dev`开始顺藤摸瓜开始vue ssr探索之旅;
1. npm run dev(node server.js)
2. 当我们访问`localhost:8080`的时候，必然会经过express 路由如下
```js
app.get('*', isProd ? render : (req, res) => {
  readyPromise.then(() => render(req, res))
})
```
由于我们的isProd 为false，也就是开发模式，我们需要关注`readyPromise`和`render`
#### render
我们知道这个函数是需要等待`readyPromise`的内容完全做完，`render`才会调用
发现`render`做了几个事
1. 设置返回头
2. 错误处理
3. 判断是否命中缓存
4. 如果没命中缓存，调用`renderer.renderToString`
`renderer`这个对象的实例化
```js
readyPromise = require('./build/setup-dev-server')(app, (bundle, options) => {
    renderer = createRenderer(bundle, options)
  })
```
#### readyPromise
看到一个`./build/setup-dev-server`
看到这个里面的代码，熟悉webpack的童鞋应该就是知道了，这里是初始化webpack
但是我们发现有两个compile
1. `clientCompiler`
2. `serverCompiler`
再看到ready函数调用的地方
```js
 const ready = (...args) => {
    resolve()
    cb(...args)
  }
```
客户端
```js
 clientCompiler.plugin('done', stats => {
    stats = stats.toJson()
    stats.errors.forEach(err => console.error(err))
    stats.warnings.forEach(err => console.warn(err))
    if (stats.errors.length) return

    clientManifest = JSON.parse(readFile(
      devMiddleware.fileSystem,
      'vue-ssr-client-manifest.json'
    ))
    if (bundle) {
      ready(bundle, {
        clientManifest
      })
    }
  })
```
服务端
```js
  const serverCompiler = webpack(serverConfig)
  const mfs = new MFS()
  serverCompiler.outputFileSystem = mfs
  serverCompiler.watch({}, (err, stats) => {
    if (err) throw err
    stats = stats.toJson()
    if (stats.errors.length) return

    // read bundle generated by vue-ssr-webpack-plugin
    bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'))
    if (clientManifest) {
      ready(bundle, {
        clientManifest
      })
    }
  })
```
也就是说每次`renderer.renderToString`的调用都是经过了webpack中间件的处理。完了之后，`renderer`才被赋值，然后被调用。
走这个过程因为这是开发环境。所以要处理es6 es7的一些语法兼容。如果走`npm run start`我们发现就不会走这个过程了。直接从`dist`文件拿来跑了
我们看看这两个Compiler 对应的入口文件：
1. entry-client.js
2. entry-server.js
#### entry-client.js
这个入口文件代码和我们平时写vue单页应用是不一样的
```js
if (window.__INITIAL_STATE__) {
  store.replaceState(window.__INITIAL_STATE__)
}
```
这里不难理解，就是客户端同步服务端组件实例化的状态。`window.__INITIAL_STATE__`
```js
TemplateRenderer.prototype.renderState = function renderState (context, options) {
  var ref = options || {};
    var contextKey = ref.contextKey; if ( contextKey === void 0 ) contextKey = 'state';
    var windowKey = ref.windowKey; if ( windowKey === void 0 ) windowKey = '__INITIAL_STATE__';
  return context[contextKey]
    ? ("<script>window." + windowKey + "=" + (serialize(context[contextKey], { isJSON: true })) + "</script>")
    : ''
};
```
她是由vue-server-renderer 这个东西生成的
**整个文件的核心在于需要同步服务端的应用状态**
#### entry-server.js
这里和entry-client.js一样引用了app.js 也就是说，整个应用的组件是前后公用的。
服务端的逻辑就是找到从路由中找到对应的组件并且初始化。通过vue-server-renderer返回给浏览器
### 总结
其实整个ssr的逻辑
服务端通过路由找到对应的组件实例化并且拼接成html字符串，状态写在window.__INITIAL_STATE__返回给客户端
客户端初始化的时候同步服务端组件状态
注意，这里接口使用了firebase，相当于外部接口，服务端，客户端可以直接使用，
如果是内部接口呢？比如我们这个服务端渲染结合我们自己的后台，想自己从我们的数据库拿数据给应用呢。
这个时候，store的actions就要分运行环境了。因为前端是xhr发起的请求，而我们后端有可能直接从数据拿过来。当然也可以在服务端访问接口，
还有一个点就是，server端访问其实是不带cookie的。






